IncludeDeclarationTop 
!{ 
#include <vector>
#include <string>
#include <map>
#include <cstdint>
#include "tinyXML\tinyxml.h"
!}

IncludeDefinitionTop !{
#include "stdafx.h"

#include <sstream>
#include "%output_name%.h"
!}

ImportInclude %{ #include "%name%.h" %}

StructDeclaration %{ extern struct %name%; %}

StructDefinition 
!{
struct %name% 
{
    %body% 
};
!}

StructDefinitionWithBase
!{
struct %name% : public %base%
{
    %body% 
};
!}

StructFieldDeclaration %{ %type% %field%; %}

MethodDeclaration %{ 
    %returnType% %method%(%param%);
%}

MethodDefinition !{ 
%returnType% %larva%::%method%(%param%)
{
    %body%
}
!}

ConstructorDeclaration %{ %name%(); %}
ConstructorDefinition !{ 
%name%::%name%()
{
    %body%
}
!}

ConstructorWithBaseDeclaration %{ %name%(); %}
ConstructorWithBaseDefinition !{ 
%name%::%name%() : %base%()
{
    %body%
}
!}

FieldInitialisation %{ %field% = %value%; %}

EnumFieldDeclaration %{ %field% , %}
EnumFieldWithValueDeclaration %{ %field% = %value% , %}
EnumValueDeclaration %{ %name%::%value% %}

EnumDeclaration !{
enum class %name% : int
{
    %body%
};
!}

type 1 default bool = bool
type 1 default int32 = int32_t
type 1 default uint32 = uint32_t
type 1 string String = std::string
type 2 array Array = std::vector<%type0%>
type 1 struct struct = !{struct %namespace%::%name%!}
type 1 enum enum = !{%namespace%::%name%!}
type 3 map Map = !{std::map<%type0%, %type1%>!}


## toXml

method toXml param = !{TiXmlElement *parentNode!}
method toXml returnType = std::string

method toXml body =
!{
TiXmlElement *parent;
if (parentNode == nullptr)
{
    parent = new TiXmlElement("%!Name%");
}
else
{
    parent = parentNode;
}

%% 

if (parentNode == nullptr)
{
    TiXmlDocument doc;
    doc.LinkEndChild(parent);

    TiXmlPrinter printer;
    printer.SetIndent("    ");
    doc.Accept(&printer);
    return printer.CStr();
}
else
{
    return "";
}
!}

method toXml body default = !{
{ // %field%
    std::stringstream oss;
    oss << %field%;
    parent->SetAttribute("%field%", oss.str().c_str());
}
!}

method toXml body enum = !{
{ // %field%
    std::stringstream oss;
    oss << (int)%field%;
    parent->SetAttribute("%field%", oss.str().c_str());
}
!}

method toXml body string = !{
{ // %field%
    std::stringstream oss;
    oss << %field%;
    parent->SetAttribute("%field%", oss.str().c_str());
}
!}

method toXml body struct = !{ 
{ // %field%
    TiXmlElement * element = new TiXmlElement("%field%");
    std::string xml = %field%.toXml(element);
    parent->LinkEndChild(element);
}
!}

method toXml body array = !{ 
// write array %field%
TiXmlElement * %field%_element = new TiXmlElement("%field%");
parent->LinkEndChild(%field%_element);
%field%_element->SetAttribute("size", %field%.size());

TiXmlElement * parent_%field% = parent;
parent = %field%_element;

for (size_t i = 0; i < %field%.size(); i++)
{
    %!Larva.SubLarvae[0].GetTypeDefinition()% &%!Larva.SubLarvae[0].Name% = %field%[i];

    %#method toXml body#%!Larva.SubLarvae[0].Name%#%!Larva.SubLarvae[0].FullName%#%
}

parent = parent_%field%;
!}

method toXml body array string = !{ 
// write array %field%
TiXmlElement * %field%_element = new TiXmlElement("%field%");
parent->LinkEndChild(%field%_element);
%field%_element->SetAttribute("size", %field%.size());

for (size_t i = 0; i < %field%.size(); i++)
{
    %!Larva.SubLarvae[0].GetTypeDefinition()% &%_value% = %field%[i];

    TiXmlElement * %_element% = new TiXmlElement("%!Larva.SubLarvae[0].Name%");
    
    std::stringstream oss;
    oss << %_value%;
    %_element%->SetAttribute("value", oss.str().c_str());

    %field%_element->LinkEndChild(%_element%);
}
!}


## fromXml

method fromXml param = !{const std::string &xml, TiXmlElement *parentNode!}
method fromXml returnType = void

method fromXml body =
!{
TiXmlElement *root;
TiXmlDocument doc;

if (parentNode == nullptr)
{
    doc.Parse(xml.c_str());
    root = doc.RootElement();
}
else
{
    root = parentNode;
}

%readDirect%

%~struct% 
%~array% 

!}

method fromXml body readDirect = !{
%~default%
%~enum%  
%~string% 
!}

method fromXml body readDirect default = !{
// %field%
root->Attribute("%field%", &%field%);
!}

method fromXml body readDirect enum = !{
// %field%
root->Attribute("%field%", (int*)&%field%);
!}

method fromXml body readDirect string = !{
// %field%
{
    const char *s = root->Attribute("%field%");
    if (s != nullptr)
    {
        %field% = s;
    }
}
!}

method fromXml body readDirect struct = !{
// %field%
%field%.fromXml("", root);
!}

method fromXml body struct = !{ 
// %field%
for (TiXmlNode *child = root->FirstChild(); child != 0; child = child->NextSibling()) 
{
    if (_stricmp(child->Value(), "%field%") == 0)
    {
        TiXmlElement *element = child->ToElement();
        %field%.fromXml("", element);
        break;
    }
}

!}

method fromXml body array = !{ 
// read array %field%
for (TiXmlNode *child = root->FirstChild(); child != 0; child = child->NextSibling()) 
{
    if (_stricmp(child->Value(), "%field%") == 0)
    {
        TiXmlElement *element = child->ToElement();

        TiXmlElement *originalRoot = root;

        for (TiXmlNode *arrayChild = element->FirstChild(); arrayChild != 0; arrayChild = arrayChild->NextSibling()) 
        {
            root = arrayChild->ToElement();
            
            %!Larva.SubLarvae[0].GetTypeDefinition()% sub;

            if (_stricmp("%!Larva.SubLarvae[0].Name%", root->Value()) == 0)
            {
                %#method fromXml body readDirect#sub#%!Larva.SubLarvae[0].FullName%#%

                %field%.push_back(sub);
            }
        }

        root = originalRoot;

        break;
    }
}
!}
